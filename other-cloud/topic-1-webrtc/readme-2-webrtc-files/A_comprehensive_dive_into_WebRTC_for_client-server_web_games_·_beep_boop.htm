<!DOCTYPE html>
<html lang="en-us"><head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      A comprehensive dive into WebRTC for client-server web games · beep boop
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/poole.css">
  <link rel="stylesheet" href="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/syntax.css">
  <link rel="stylesheet" href="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/lanyon.css">
  <link rel="stylesheet" href="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/css.css">

  <!-- Icons -->
  <link rel="shortcut icon" href="https://brkho.github.io/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.brkho.com/atom.xml">

  <script async="" src="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/analytics.js"></script><script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-93787017-1', 'auto');
    ga('send', 'pageview');

  </script>
<script src="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/embed.js" data-timestamp="1677691218142"></script></head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Hi, I'm <a href="https://twitter.com/brkhoot">Brian</a>! Here you'll find my general musings on game development and updates on a browser game that I'm building out in my spare time.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="https://brkho.github.io/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="https://brkho.github.io/about/">About</a>
        
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/brkho">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      © 2017.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://brkho.github.io/" title="Home">beep boop</a>
            <small>a game development blog</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">A comprehensive dive into WebRTC for client-server web games</h1>
  <span class="post-date">15 Mar 2017</span>
  <p>Multiplayer games are fun. For what they lack in single player 
immersion, online games compensate with uniquely rewarding experiences 
in questing with friends, meeting strangers online, and clashing head to
 head against competent peers. One needs to look no further than the 
giants of League of Legends, Hearthstone, and Overwatch to realize the 
mass demand for multiplayer games.<sup>1</sup> While these franchises 
are successful, however, they have significant barriers to entry in 
their multi-gigabyte game clients. Sure, an installation won’t deter a 
hardcore gamer, but for the many casual players out there, the extra 
step is a non-starter.</p>

<p>For this reason, web games have enormous potential when it comes to 
massively multiplayer experiences. While downloading and installing a 
client might be too much for some, playing a game by simply <em>visiting</em>
 a web page is low-friction and conducive to virality. I’m currently 
building such a game, and in this blog post, I’d like to share my 
experiences in establishing a raw connection between a browser and the 
game server.</p>

<p>tl;dr: If you’re already familiar with the concepts, you can check out <a href="https://github.com/brkho/client-server-webrtc-example">the full example code</a> to get started.</p>

<!--break-->
<h2 id="tcp-vs-udp">TCP vs. UDP</h2>
<p>One of the first steps in developing any multiplayer game is to 
decide on a transport layer protocol, the two most popular by far being 
TCP and UDP. Numerous resources have covered the differences extensively<sup>2,3</sup>,
 so I’ll only give this topic a brief treatment. In short, UDP is a 
simple connectionless protocol that allows a source to send individual 
packets to a destination. Because of the unreliable nature of the 
network, some packets might get dropped or arrive at the destination at 
different times, for which UDP does not offer any safeguards. TCP, on 
the other hand, is connection-based and guarantees that packets are 
delivered and received in the order sent by the source. This, of course,
 comes at the expense of speed because the source will need 
acknowledgement that a packet was actually received before sending the 
next one.</p>

<p>While TCP has been used in many successful games (most notably World 
of Warcraft), most modern online games favor UDP because packet 
retransmission in the event of dropped packets and its associated 
latency is not only unnecessary but also unacceptable during fast-paced 
gameplay. UDP is definitely a bit more complicated to work with, but 
with some effort<sup>4</sup>, you can leverage its flexibility to your advantage and avoid bloating your ping.</p>

<h2 id="udp-on-the-browser">UDP on the browser</h2>
<p>“That sounds great,” you say, “but what’s the catch?” Normally, there
 is no catch as long as you take care in guarding against transmission 
failures and network congestion. Unfortunately for us, there is one <em>really</em>
 big catch when it comes to web games– for security reasons, there is no
 cross-platform way of sending or receiving packets via UDP in the 
browser<sup>5</sup>. Most online web games like <a href="http://agar.io/">agar.io</a>
 instead rely on WebSockets for networking which exposes a clean 
interface for TCP connections with a server. However, as I mentioned 
earlier, TCP breaks down where sub-second reactions are necessary, so 
does this mean we’re stuck distributing our shooters and MOBAs as native
 clients?</p>

<h2 id="saved-by-webrtc">Saved by WebRTC</h2>
<p>Of course not! No matter how convoluted the solution, the web will 
always find a way. Enter WebRTC, a browser API that enables real-time 
communication for peer-to-peer connections<sup>6</sup>. While the bulk 
of WebRTC is tailored for media transfer (e.g. voice chat in Discord’s 
web app or video calling in web Messenger), it contains a small, often 
overlooked specification called Data Channels which allows for sending 
arbitrary messages between two peer browsers.</p>

<p>I mentioned earlier that TCP and UDP are the most popular transport 
layer protocols, but they are far from the only ones. WebRTC data 
channels use the Stream Control Transmission Protocol (SCTP) which is 
connection oriented like TCP but allows for configurability when it 
comes to reliability and delivery of packets. In other words, SCTP can 
be configured to behave like TCP with guaranteed delivery and ordering 
of packets, or we can turn those features off to end up with something 
analogous to UDP.</p>

<p>So this is great; with WebRTC data channels, we can send messages 
over SCTP configured to behave like UDP, solving our problem perfectly. 
As it turns out, however, WebRTC is a roaring beast that shakes the 
Earth with the force of a thousand monsoons when you attempt to set it 
up. In fact, the last few times WebRTC was mentioned on Hacker News in a
 gaming context, many commenters noted how they were either unable to 
get it working or deterred by its complexity from even trying<sup>7,8</sup>.
 In addition, WebRTC is meant for peer-to-peer connections, whereas most
 competitive networked games today require a client-server model to 
prevent cheating<sup>9</sup>. Of course, we have no other option but to 
treat the server as just another neighborhood “peer” which presents 
extra hoops to jump through to get a connection going.</p>

<h2 id="challenges-in-peer-to-peer-networking">Challenges in peer-to-peer networking</h2>
<p>Continuing with the theme of inconveniences, peer-to-peer 
communication over modern networks presents yet another challenge in 
itself. In an ideal world, every client would have its own fixed IP 
address that other clients can use to establish direct connections. 
However, the IPv4 address space is limited in practice to around three 
billion unique addresses, barely sufficient for every other person in 
the world to have a single internet-connected computer, let alone 
additional tablets, laptops, and IoT immersion cookers. As a temporary 
fix in the lull before IPv6, most home and corporate networks employ a 
process known as Network Address Translation (NAT).</p>

<p>Without going into too much detail, a NAT device such as a home 
router manages the connections of all computers within its network. For 
example, all of the internet-connected devices in your apartment most 
likely sit behind a single router which has a <em>public facing IP</em> such as <code class="highlighter-rouge">50.50.50.50</code>. To conserve the IPv4 address space, your consumer devices all share the NAT device’s public IP while each is assigned its own <em>local IP</em> that is unique only within the local network (such as <code class="highlighter-rouge">192.168.0.10</code>).
 Of course, computers on the wider internet cannot contact or uniquely 
identify your home computer using its local address; thousands, if not 
millions of devices across the world all have the same local IP.</p>

<p>This is where Network Address Translation comes into play. While 
foreign devices can’t contact your computer directly, they can get <em>pretty close</em> by contacting the distinct public IP of the NAT device your computer is behind. The router can then <em>translate</em> the incoming request into a local address using a lookup table and subsequently forward the request on to your home computer.</p>

<p>More concretely, your computer will contact a server by first sending
 its request to the router which in turn associates that computer’s 
local IP with a free port on the NAT device. It then sends the request 
out to the intended destination by replacing the sender address with the
 NAT device’s IP combined with the port it just assigned to your home 
computer. For example, the NAT device might forward a request to the 
destination server that appears to originate from <code class="highlighter-rouge">50.50.50.50:20000</code>.</p>

<p>The server, however, doesn’t care if the requesting address results 
from NAT; when it’s ready, the server will simply send its response back
 to whatever address was supplied in the sender field. This results in 
the server sending a response back to the NAT device along the port 
uniquely associated with your home computer. The NAT device will then 
receive the server’s response and route it to the correct computer using
 a lookup table. Thus, the IPv4 address space is conserved with all of 
the indirection required to do so abstracted away from both the client 
and server. With NAT, everyone’s happy!</p>

<p>Well, except us. In the previous example, we assumed the home computer already knew the public IP of a server that is <em>not</em>
 behind NAT. WebRTC, on the other hand, is designed for peer-to-peer 
connections where both parties are likely to be behind a NAT device and 
neither address is already known. WebRTC thus mandates an intermediate 
discovery step called NAT traversal that we must implement even though 
in our client-server use case, the address of the server is actually 
known beforehand.</p>

<p>The most lightweight protocol for this step is known as STUN in which
 peers ping a dedicated server called a STUN server to discover their 
public IP address and port combinations (such as <code class="highlighter-rouge">50.50.50.50:20000</code>).
 Both peers request their addresses from the STUN server, and the STUN 
server sends back the public IP and port it received the request on. 
Both peers now effectively know their own “public” IPs from the STUN 
server’s response which they can use to begin establishing a WebRTC 
connection.</p>

<p>Unfortunately, as a final complication, corporate networks often 
employ special types of NAT such as symmetric NAT for which STUN is 
ineffective for reasons we’ll get into at the end of this blog post. In 
these rare cases, we are forced to use other protocols such as TURN to 
establish a connection. To manage the alphabet soup of possible NAT 
traversal protocols, WebRTC uses yet another protocol called ICE to rule
 them all. ICE performs checks on the network and uses STUN if it’s 
available, and if not, falls back to a more complex protocol like TURN. 
We will continue under the assumption that we are on a traditional home 
network that supports STUN.</p>

<h2 id="webrtc-peer-connection-and-data-channels">WebRTC Peer Connection and Data Channels</h2>
<p>With all of the background information out of the way, I’ll now 
present a high level overview of the WebRTC data channel creation 
process and then jump into the actual code necessary for setting up your
 own client and server.</p>

<p>WebRTC provides an interface called <code class="highlighter-rouge">RTCPeerConnection</code> that serves as the starting point to create any type of connection, data channel or otherwise. The client can initialize an <code class="highlighter-rouge">RTCPeerConnection</code>
 object and begin to look for other peer clients to connect to and begin
 exchanging data. Of course, at this point the client has no way of 
directly knowing what other clients are out there. In WebRTC terms, we 
solve this through an application-specific process known as <em>signaling</em>
 where two peers exchange a handshake through a known server and learn 
of each other’s “public” IP using ICE and STUN. As a real world example,
 two friends on Messenger can only initiate a peer-to-peer call after 
they both exchange their publicly accessible addresses through 
Facebook’s central servers.</p>

<p>After the signaling process, both clients know how to directly contact the other and have all the information that <em>should</em>
 be needed to send arbitrary packets. As we mentioned earlier, however, 
WebRTC is geared towards media transfer and also requires clients to 
exchange data about their media capabilities before <em>any</em> type of
 connection is finalized. Even though we’re not using any part of the 
media APIs, we are still mandated by WebRTC to make the full media 
handshake before a data channel is opened. This handshake, known as the 
Session Description Protocol (SDP) is as follows:</p>

<ol>
  <li>Client 1 and Client 2 both connect to some pre-defined server known as the signaling server.</li>
  <li>They learn of each other’s existence through the signaling server, and they decide to initiate a connection.</li>
  <li>Client 1 creates an “offer” using <code class="highlighter-rouge">RTCPeerConnection.createOffer</code>
 which subsequently contains information about Client 1’s media 
capabilities (for example, if it has a webcam or can play audio).</li>
  <li>Client 1 sends the offer to Client 2 by proxying through the signaling server.</li>
  <li>Client 2 receives the offer from the signaling server and passes it to <code class="highlighter-rouge">RTCPeerConnection.createAnswer</code> to create an “answer” with Client 2’s own media capabilities.</li>
  <li>Client 2 sends the answer back to Client 1 through the signaling server.</li>
  <li>Client 1 receives and verifies the answer. It then starts the ICE 
protocol which in our example, contacts the STUN server to discover its 
public IP. When the STUN server responds, it sends this information 
(known as an “ICE candidate”) to Client 2 through the signaling server.</li>
  <li>Client 2 receives Client 1’s ICE candidates, finds its own ICE 
candidates via the same mechanism, and sends them to Client 1 via the 
signaling server.</li>
  <li>Each client now knows the other one’s media capabilities and 
publicly accessible IPs. They exchange direct pings without the aid of 
the signaling server, and the connection is established. The two clients
 can now happily send each other messages through the <code class="highlighter-rouge">RTCDataChannel</code> API.</li>
</ol>

<h2 id="webrtc-in-a-client-server-model">WebRTC in a client-server model</h2>
<p>At the end of the day, we can just treat the game client as “Client 
1” and the game server as “Client 2” and follow the complicated, but 
well-defined WebRTC protocol to establish a client-server connection. 
Implementing the WebRTC connection on the client is straightforward; 
WebRTC is first and foremost a browser API, so we can just call the 
correct functions that most modern browsers provide.</p>

<p>While WebRTC has fairly decent browser support, using the WebRTC API 
on the server is a completely different story. For some personal flavor,
 I was originally writing my game server in JavaScript with Node.js. I 
started out using <a href="https://github.com/js-platform/node-webrtc/">node-webrtc</a> which is a JavaScript wrapper around the Chromium WebRTC library. However, I soon found that <code class="highlighter-rouge">node-webrtc</code> depends on extremely old WebRTC binaries that use an outdated SDP handshake incompatible with modern Chrome<sup>10</sup>. I then pivoted to <a href="https://github.com/mappum/electron-webrtc">electron-webrtc</a>
 which simply runs a headless electron client in the background that 
offers its WebRTC capabilities through interprocess communication. I was
 able to get a basic connection going with <code class="highlighter-rouge">electron-webrtc</code>
 without much difficulty, but I had concerns about its scalability 
resulting from the extra overhead in shuffling data between the main 
process and a full-fledged electron application.</p>

<p>At the end of the day, I realized that I’m just not that comfortable 
reasoning about performance in JavaScript and that my game server 
requires a platform with strong multithreading support. I decided to cut
 all the excess and take the traditional route of building my game 
server in C++. For WebRTC functionality, I can then link Chromium’s 
WebRTC library which is also written in native code.</p>

<p>So now we have our client running in the browser with JavaScript, our
 server running in C++, but we still have the one more piece of the 
puzzle– the signaling server that connects the two peers. Fortunately, 
we can cut corners here for once because the game server is a special 
peer that we actually know the direct address of beforehand. We can 
simply run a lightweight WebSockets library in the background of our 
game server and easily connect to it via TCP from the client. The client
 can then send WebRTC offers via the WebSocket, and the server can 
process the data locally without having to forward it like in a 
traditional signaling server.</p>

<h2 id="implementation">Implementation</h2>
<p>We’ve covered a lot of information, and now let’s finally put it all 
together in a minimal example of a client-server WebRTC connection. For 
the sake of consistency, my client is running on OS X and Chrome 56, and
 my server is running on Ubuntu 16.04 on a <code class="highlighter-rouge">c4.xlarge</code> EC2 instance (overkill for a development server, but hey I have credits that expire soon). I’m compiling my server with <code class="highlighter-rouge">gcc 5.4</code>. The full source code of both the client and the server are available <a href="https://github.com/brkho/client-server-webrtc-example">on my GitHub</a> which should help you follow along.</p>

<p>The first thing we need to do is set up the server dependencies. If 
you’re not very comfortable wrangling C++ build tools, you can clone the
 fully functional repo I linked above and use that as a starting point. 
We will be using <a href="https://github.com/zaphoyd/websocketpp">WebSocket++</a>,
 a header-only C++ WebSockets implementation for our pseudo-signaling 
server. WebSocket++ itself depends on Boost.Asio for asynchronous 
programming which we can easily install with <code class="highlighter-rouge">apt-get install libboost-all-dev</code>. Since WebSocket++ is a header-only library, we can simply clone the repo and copy the <code class="highlighter-rouge">websocketpp</code> subdirectory into our include path.</p>

<p>We also need a format for sending structured messages between the 
client and the server. In production, I would use a compact and 
performant serialization solution such as <a href="https://github.com/google/protobuf">Protocol Buffers</a>,
 but for the purposes of this demo, we’ll just use JSON because of its 
first class support in JavaScript. On the server side, I’ll use <a href="https://github.com/miloyip/rapidjson">rapidjson</a> to parse and serialize data. Like WebSocket++, this is a header-only library, so you can just clone the repo and copy the <code class="highlighter-rouge">include/rapidjson</code> subdirectory into the include path.</p>

<p>Next we have to build and install <a href="https://chromium.googlesource.com/external/webrtc">Chromium’s WebRTC library</a>.
 This is the library used in Chrome for its WebRTC functionality, so 
it’s guaranteed to be correct and efficient. I originally built it from 
scratch, but this is a pain because you need to clone the repo, build 
with the Chromium-specific build tools, and place the output into the 
shared libraries folder. I recently found a <a href="https://github.com/aisouard/libwebrtc">nice collection of scripts</a> that do the heavy lifting for you which I highly recommend using for your own sanity.</p>

<p>Even with this convenient utility, I still ran into issues when the 
most recent commit on Chromium master failed to build on my machine. I 
had to go a few commits back before finding a green build. I settled on 
commit <code class="highlighter-rouge">3dda246b69</code>, so if you have trouble building WebRTC, I recommend starting with the same commit hash. If you’re using aisouard’s <code class="highlighter-rouge">libwebrtc</code>
 scripts linked above, the way to specify a commit of WebRTC to build 
unfortunately has changed since I first started using it. As such, I’ve 
locked my server setup process to use commit <code class="highlighter-rouge">83814ef6f3</code> of the <code class="highlighter-rouge">libwebrtc</code> scripts, so <code class="highlighter-rouge">checkout</code> that revision if you want to follow along. All said and done, you can install WebRTC in just a few commands:</p>
<div class="language-shell highlighter-rouge"><pre class="highlight"><code>apt-get install build-essential libglib2.0-dev libgtk2.0-dev libxtst-dev <span class="se">\</span>
  libxss-dev libpci-dev libdbus-1-dev libgconf2-dev <span class="se">\</span>
  libgnome-keyring-dev libnss3-dev libasound2-dev libpulse-dev <span class="se">\</span>
  libudev-dev cmake
git clone https://github.com/aisouard/libwebrtc.git
<span class="nb">cd </span>libwebrtc
<span class="gp">&lt;OPTIONAL&gt; </span>git checkout 83814ef6f3
<span class="gp">&lt;OPTIONAL&gt; </span>vim CMakeModules/Version.cmake
<span class="gp">&lt;OPTIONAL&gt; </span>change the LIBWEBRTC_WEBRTC_REVISION <span class="nb">hash </span>to 3dda246b69df7ff489660e0aee0378210104240b
git submodule init
git submodule update
mkdir out
<span class="nb">cd </span>out
cmake ..
make
make install
</code></pre>
</div>

<p>We now have all of our server dependencies, so let’s get a basic 
WebSockets connection going. This is the full code for getting it off 
the ground:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="cp">#include &lt;websocketpp/config/asio_no_tls.hpp&gt;
#include &lt;websocketpp/server.hpp&gt;
</span>
<span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">lib</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">;</span>
<span class="k">using</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">lib</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">;</span>
<span class="k">using</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">lib</span><span class="o">::</span><span class="n">bind</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">server</span><span class="o">&lt;</span><span class="n">websocketpp</span><span class="o">::</span><span class="n">config</span><span class="o">::</span><span class="n">asio</span><span class="o">&gt;</span> <span class="n">WebSocketServer</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">WebSocketServer</span><span class="o">::</span><span class="n">message_ptr</span> <span class="n">message_ptr</span><span class="p">;</span>

<span class="c1">// The WebSocket server being used to handshake with the clients.
</span><span class="n">WebSocketServer</span> <span class="n">server</span><span class="p">;</span>

<span class="c1">// Callback for when the WebSocket server receives a message from the client.
</span><span class="kt">void</span> <span class="nf">OnWebSocketMessage</span><span class="p">(</span><span class="n">WebSocketServer</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">connection_hdl</span> <span class="n">hdl</span><span class="p">,</span> <span class="n">message_ptr</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">get_payload</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// In a real game server, you would run the WebSocket server as a separate thread so your main process can handle the game loop.
</span>  <span class="n">server</span><span class="p">.</span><span class="n">set_message_handler</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">OnWebSocketMessage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="o">::</span><span class="n">_2</span><span class="p">));</span>
  <span class="n">server</span><span class="p">.</span><span class="n">init_asio</span><span class="p">();</span>
  <span class="n">server</span><span class="p">.</span><span class="n">set_reuse_addr</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">server</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
  <span class="n">server</span><span class="p">.</span><span class="n">start_accept</span><span class="p">();</span>
  <span class="c1">// I don't do it here, but you should gracefully handle closing the connection.
</span>  <span class="n">server</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This code shouldn’t look too complicated; we’re just creating a 
WebSocketServer object backed by asio, setting a message handler, and 
calling some configuration methods. As noted in the comments, this will 
cause your main server to run the WebSocket listening loop preventing it
 from doing anything else. In a real project, you should run the 
WebSocket server as a separate thread. You can verify that your 
WebSocket server is actually running by invoking <code class="highlighter-rouge">telnet &lt;server IP&gt; 8080</code> from your personal machine.</p>

<p>The corresponding client code to communicate with the WebSocket on the server is similarly straightforward.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="c1">// URL to the server with the port we are using for WebSockets.</span>
<span class="kr">const</span> <span class="nx">webSocketUrl</span> <span class="o">=</span> <span class="s1">'ws://&lt;replace with server address&gt;:8080'</span><span class="p">;</span>
<span class="c1">// The WebSocket object used to manage a connection.</span>
<span class="kd">let</span> <span class="nx">webSocketConnection</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="c1">// Callback for when the WebSocket is successfully opened.</span>
<span class="kd">function</span> <span class="nx">onWebSocketOpen</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Opened!'</span><span class="p">);</span>
  <span class="nx">webSocketConnection</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Hello, world!'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Callback for when we receive a message from the server via the WebSocket.</span>
<span class="kd">function</span> <span class="nx">onWebSocketMessage</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Connects by creating a new WebSocket connection and associating some callbacks.</span>
<span class="kd">function</span> <span class="nx">connect</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">webSocketConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="nx">webSocketUrl</span><span class="p">);</span>
  <span class="nx">webSocketConnection</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nx">onWebSocketOpen</span><span class="p">;</span>
  <span class="nx">webSocketConnection</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nx">onWebSocketMessage</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>While simple, this demonstrates all of the functionality we need: 
creating a new WebSocket on the client, assigning some callbacks, and 
sending a message. If you call <code class="highlighter-rouge">connect</code>, you should see “Opened!” print on the browser console and “Hello, world!” print on the server’s standard output.</p>

<p>We can now instantiate an <code class="highlighter-rouge">RTCPeerConnection</code> and an <code class="highlighter-rouge">RTCDataChannel</code> which are part of the browser API. <code class="highlighter-rouge">RTCPeerConnection</code> is then used to create an offer for SDP which is sent to the server via our WebSockets connection.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onWebSocketOpen</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{</span> <span class="na">iceServers</span><span class="p">:</span> <span class="p">[{</span> <span class="na">url</span><span class="p">:</span> <span class="s1">'stun:stun.l.google.com:19302'</span> <span class="p">}]</span> <span class="p">};</span>
  <span class="nx">rtcPeerConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCPeerConnection</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">dataChannelConfig</span> <span class="o">=</span> <span class="p">{</span> <span class="na">ordered</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">maxRetransmits</span><span class="p">:</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="nx">dataChannel</span> <span class="o">=</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createDataChannel</span><span class="p">(</span><span class="s1">'dc'</span><span class="p">,</span> <span class="nx">dataChannelConfig</span><span class="p">);</span>
  <span class="nx">dataChannel</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nx">onDataChannelMessage</span><span class="p">;</span>
  <span class="nx">dataChannel</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nx">onDataChannelOpen</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">sdpConstraints</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">mandatory</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">OfferToReceiveAudio</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">OfferToReceiveVideo</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">};</span>
  <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">onicecandidate</span> <span class="o">=</span> <span class="nx">onIceCandidate</span><span class="p">;</span>
  <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createOffer</span><span class="p">(</span><span class="nx">onOfferCreated</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{},</span> <span class="nx">sdpConstraints</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We create the <code class="highlighter-rouge">RTCPeerConnection</code> with a URL to a STUN server. <code class="highlighter-rouge">stun:stun.l.google.com:19302</code> is a public STUN server kindly maintained by Google for development use, so it is recommended to set up <a href="http://www.stunprotocol.org/">your own STUN server</a> for use in production. Next, we create a data channel associated with the <code class="highlighter-rouge">RTCPeerConnection</code>
 and specify to use unordered, unreliable SCTP in the configuration 
object. We bind some callbacks which we’ll come back to later, and we 
attempt to create an SDP offer. The first argument of <code class="highlighter-rouge">createOffer</code>
 is a callback for creation success, the second argument is a callback 
for creation failure, and the final argument is a self-explanatory 
configuration object. The actual offer is passed to the success 
callback.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onOfferCreated</span><span class="p">(</span><span class="nx">description</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setLocalDescription</span><span class="p">(</span><span class="nx">description</span><span class="p">);</span>
  <span class="nx">webSocketConnection</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'offer'</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="nx">description</span><span class="p">}));</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In the offer callback, we store the client’s own media capabilities by calling <code class="highlighter-rouge">setLocalDescription</code>
 and then send our offer over the WebSocket as stringified JSON. On the 
server side, we can handle this request by parsing the JSON.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="cp">#include &lt;rapidjson/document.h&gt;
</span>
<span class="n">OnWebSocketMessage</span><span class="p">(</span><span class="n">WebSocketServer</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">connection_hdl</span> <span class="n">hdl</span><span class="p">,</span> <span class="n">message_ptr</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Document</span> <span class="n">message_object</span><span class="p">;</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">get_payload</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
  <span class="c1">// Probably should do some error checking on the JSON object.
</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">type</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"type"</span><span class="p">].</span><span class="n">GetString</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="s">"offer"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sdp</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"payload"</span><span class="p">][</span><span class="s">"sdp"</span><span class="p">].</span><span class="n">GetString</span><span class="p">();</span>
    <span class="c1">// Do some some stuff with the offer.
</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unrecognized WebSocket message type."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<p>At this point, we want to create an <code class="highlighter-rouge">RTCPeerConnection</code> and an <code class="highlighter-rouge">RTCDataChannel</code>
 on the server so we can process the client’s offer and generate an 
answer. Unfortunately as it goes with C++, there’s a fair amount of 
boilerplate code required to accomplish the same task that takes 15 
lines of JavaScript. The main difference is that the WebRTC library uses
 <a href="https://en.wikipedia.org/wiki/Observer_pattern">the observer pattern</a> to handle WebRTC events like <code class="highlighter-rouge">onmessage</code> and <code class="highlighter-rouge">onOfferCreated</code>
 instead of convenient JS callbacks. To even get a peer connection 
running, we have to implement all 19 possible events by overriding the <code class="highlighter-rouge">webrtc::*Observer</code> family of abstract classes.</p>
<ul>
  <li><code class="highlighter-rouge">webrtc::PeerConnectionObserver</code> for peer connection events such as receiving ICE candidates.</li>
  <li><code class="highlighter-rouge">webrtc::CreateSessionDescriptionObserver</code> for creating an offer or answer.</li>
  <li><code class="highlighter-rouge">webrtc::SetSessionDescriptionObserver</code> for acknowledging and storing an offer or answer.</li>
  <li><code class="highlighter-rouge">webrtc::DataChannelObserver</code> for data channel events like receiving SCTP messages.</li>
</ul>

<p>I provide <a href="https://github.com/brkho/client-server-webrtc-example/blob/master/server/src/observers.h">observers.h</a>
 which implements no-ops for most of these event methods to ease your 
development. In practice, we only care about a few of these events 
anyways. For the events we do need to act on, we provide callback 
functions that we will later define in <code class="highlighter-rouge">main.cpp</code>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="cp">#include "observers.h"
</span>
<span class="kt">void</span> <span class="n">OnDataChannelCreated</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">DataChannelInterface</span><span class="o">*</span> <span class="n">channel</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">OnIceCandidate</span><span class="p">(</span><span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">IceCandidateInterface</span><span class="o">*</span> <span class="n">candidate</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">OnDataChannelMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">DataBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">OnAnswerCreated</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">SessionDescriptionInterface</span><span class="o">*</span> <span class="n">desc</span><span class="p">);</span>

<span class="n">PeerConnectionObserver</span> <span class="n">peer_connection_observer</span><span class="p">(</span><span class="n">OnDataChannelCreated</span><span class="p">,</span> <span class="n">OnIceCandidate</span><span class="p">);</span>
<span class="n">DataChannelObserver</span> <span class="n">data_channel_observer</span><span class="p">(</span><span class="n">OnDataChannelMessage</span><span class="p">);</span>
<span class="n">CreateSessionDescriptionObserver</span> <span class="n">create_session_description_observer</span><span class="p">(</span><span class="n">OnAnswerCreated</span><span class="p">);</span>
<span class="n">SetSessionDescriptionObserver</span> <span class="n">set_session_description_observer</span><span class="p">;</span>
</code></pre>
</div>

<p>We now need to understand a little about <a href="https://webrtc.org/native-code/native-apis/#threading-model">WebRTC’s threading model</a>.
 In short, WebRTC requires two threads for its operation– the signaling 
thread and the worker thread. The signaling thread handles the bulk of 
WebRTC computation; it creates all of the basic components and fires 
events we can consume by calling the observer methods defined in <code class="highlighter-rouge">observers.h</code>.
 The worker thread, on the other hand, is delegated resource-intensive 
tasks such as media streaming to ensure that the signaling thread 
doesn’t get blocked. WebRTC will automatically create both threads for 
us if we use a <code class="highlighter-rouge">PeerConnectionFactory</code>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="cp">#include &lt;webrtc/api/peerconnectioninterface.h&gt;
#include &lt;webrtc/base/physicalsocketserver.h&gt;
#include &lt;webrtc/base/ssladapter.h&gt;
#include &lt;webrtc/base/thread.h&gt;
</span>
<span class="cp">#include &lt;thread&gt;
</span>
<span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">PeerConnectionFactoryInterface</span><span class="o">&gt;</span> <span class="n">peer_connection_factory</span><span class="p">;</span>
<span class="n">rtc</span><span class="o">::</span><span class="n">PhysicalSocketServer</span> <span class="n">socket_server</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">webrtc_thread</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">SignalThreadEntry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Create the PeerConnectionFactory.
</span>  <span class="n">rtc</span><span class="o">::</span><span class="n">InitializeSSL</span><span class="p">();</span>
  <span class="n">peer_connection_factory</span> <span class="o">=</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CreatePeerConnectionFactory</span><span class="p">();</span>
  <span class="n">rtc</span><span class="o">::</span><span class="n">Thread</span><span class="o">*</span> <span class="n">signaling_thread</span> <span class="o">=</span> <span class="n">rtc</span><span class="o">::</span><span class="n">Thread</span><span class="o">::</span><span class="n">Current</span><span class="p">();</span>
  <span class="n">signaling_thread</span><span class="o">-&gt;</span><span class="n">set_socketserver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">socket_server</span><span class="p">);</span>
  <span class="n">signaling_thread</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
  <span class="n">signaling_thread</span><span class="o">-&gt;</span><span class="n">set_socketserver</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">webrtc_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">SignalThreadEntry</span><span class="p">);</span>
  <span class="c1">// ... set up the WebSocket server.
</span><span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">CreatePeerConnectionFactory</code> 
will set the current thread to the signaling thread and create some 
worker thread in the background. Since we’re using the main thread for 
the WebSocket listening loop, we need to create a new <code class="highlighter-rouge">webrtc_thread</code> so both WebRTC and WebSockets can coexist.</p>

<p>In the WebRTC thread entry function, we instantiate a <code class="highlighter-rouge">PeerConnectionFactory</code>
 which will designate that thread as the signaling thread. After 
performing some setup such as providing a socket to communicate with the
 worker thread, we can finally use the factory to spawn an <code class="highlighter-rouge">RTCPeerConnection</code> and respond to the SDP.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">PeerConnectionInterface</span><span class="o">&gt;</span> <span class="n">peer_connection</span><span class="p">;</span>
<span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">DataChannelInterface</span><span class="o">&gt;</span> <span class="n">data_channel</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">OnWebSocketMessage</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="c1">// ... parse the JSON.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="s">"offer"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sdp</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"payload"</span><span class="p">][</span><span class="s">"sdp"</span><span class="p">].</span><span class="n">GetString</span><span class="p">();</span>
    <span class="n">webrtc</span><span class="o">::</span><span class="n">PeerConnectionInterface</span><span class="o">::</span><span class="n">RTCConfiguration</span> <span class="n">configuration</span><span class="p">;</span>
    <span class="n">webrtc</span><span class="o">::</span><span class="n">PeerConnectionInterface</span><span class="o">::</span><span class="n">IceServer</span> <span class="n">ice_server</span><span class="p">;</span>
    <span class="n">ice_server</span><span class="p">.</span><span class="n">uri</span> <span class="o">=</span> <span class="s">"stun:stun.l.google.com:19302"</span><span class="p">;</span>
    <span class="n">configuration</span><span class="p">.</span><span class="n">servers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ice_server</span><span class="p">);</span>

    <span class="c1">// Create the RTCPeerConnection with an observer.
</span>    <span class="n">peer_connection</span> <span class="o">=</span> <span class="n">peer_connection_factory</span><span class="o">-&gt;</span><span class="n">CreatePeerConnection</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peer_connection_observer</span><span class="p">);</span>
    <span class="n">webrtc</span><span class="o">::</span><span class="n">DataChannelInit</span> <span class="n">data_channel_config</span><span class="p">;</span>
    <span class="n">data_channel_config</span><span class="p">.</span><span class="n">ordered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data_channel_config</span><span class="p">.</span><span class="n">maxRetransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Create the RTCDataChannel with an observer.
</span>    <span class="n">data_channel</span> <span class="o">=</span> <span class="n">peer_connection</span><span class="o">-&gt;</span><span class="n">CreateDataChannel</span><span class="p">(</span><span class="s">"dc"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_channel_config</span><span class="p">);</span>
    <span class="n">data_channel</span><span class="o">-&gt;</span><span class="n">RegisterObserver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_channel_observer</span><span class="p">);</span>

    <span class="n">webrtc</span><span class="o">::</span><span class="n">SdpParseError</span> <span class="n">error</span><span class="p">;</span>
    <span class="n">webrtc</span><span class="o">::</span><span class="n">SessionDescriptionInterface</span><span class="o">*</span> <span class="n">session_description</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">CreateSessionDescription</span><span class="p">(</span><span class="s">"offer"</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">));</span>
    <span class="c1">// Store the client's SDP offer.
</span>    <span class="n">peer_connection</span><span class="o">-&gt;</span><span class="n">SetRemoteDescription</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_session_description_observer</span><span class="p">,</span> <span class="n">session_description</span><span class="p">);</span>
    <span class="c1">// Creates an answer to send back.
</span>    <span class="n">peer_connection</span><span class="o">-&gt;</span><span class="n">CreateAnswer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">create_session_description_observer</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// ... handle other cases.
</span><span class="p">}</span>
</code></pre>
</div>

<p>While this looks complicated, it is essentially doing the same thing 
as the JavaScript code we wrote for the client. First we create an <code class="highlighter-rouge">RTCPeerConnection</code>
 with Google’s development STUN server and use it to create a data 
channel that transmits via unordered, unreliable SCTP. Finally, we store
 the client’s offer using <code class="highlighter-rouge">SetRemoteDescription</code> and create an answer to send back to the client. <code class="highlighter-rouge">CreateAnswer</code> will trigger the <code class="highlighter-rouge">OnSuccess</code> event of <code class="highlighter-rouge">CreateSessionDescriptionObserver</code>. This will in turn invoke our <code class="highlighter-rouge">OnAnswerCreated</code> callback to which we can add code for sending the answer to the client.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="cp">#include &lt;rapidjson/stringbuffer.h&gt;
#include &lt;rapidjson/writer.h&gt;
</span>
<span class="kt">void</span> <span class="n">OnAnswerCreated</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">SessionDescriptionInterface</span><span class="o">*</span> <span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">peer_connection</span><span class="o">-&gt;</span><span class="n">SetLocalDescription</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_session_description_observer</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">offer_string</span><span class="p">;</span>
  <span class="n">desc</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offer_string</span><span class="p">);</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Document</span> <span class="n">message_object</span><span class="p">;</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">SetObject</span><span class="p">();</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"type"</span><span class="p">,</span> <span class="s">"answer"</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Value</span> <span class="n">sdp_value</span><span class="p">;</span>
  <span class="n">sdp_value</span><span class="p">.</span><span class="n">SetString</span><span class="p">(</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">StringRef</span><span class="p">(</span><span class="n">offer_string</span><span class="p">.</span><span class="n">c_str</span><span class="p">()));</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Value</span> <span class="n">message_payload</span><span class="p">;</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">SetObject</span><span class="p">();</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"type"</span><span class="p">,</span> <span class="s">"answer"</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"sdp"</span><span class="p">,</span> <span class="n">sdp_value</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"payload"</span><span class="p">,</span> <span class="n">message_payload</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">StringBuffer</span> <span class="n">strbuf</span><span class="p">;</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">StringBuffer</span><span class="o">&gt;</span> <span class="n">writer</span><span class="p">(</span><span class="n">strbuf</span><span class="p">);</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">strbuf</span><span class="p">.</span><span class="n">GetString</span><span class="p">();</span>
  <span class="n">ws_server</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">websocket_connection_handler</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">frame</span><span class="o">::</span><span class="n">opcode</span><span class="o">::</span><span class="n">value</span><span class="o">::</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We store the server’s own answer (passed in as the argument) using <code class="highlighter-rouge">SetLocalDescription</code>. Here, we encounter <code class="highlighter-rouge">rapidjson's</code>
 extremely poor code ergonomics, but hopefully it’s clear that all we’re
 doing is building a simple JSON blob field by field. Once we build the 
message, we stringify it and send the answer back to the client.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onWebSocketMessage</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">messageObject</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">messageObject</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'answer'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setRemoteDescription</span><span class="p">(</span><span class="k">new</span> <span class="nx">RTCSessionDescription</span><span class="p">(</span><span class="nx">messageObject</span><span class="p">.</span><span class="nx">payload</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Unrecognized WebSocket message type.'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We handle the message by parsing it to get its type and payload. The 
client proceeds to stores the server’s SDP answer by calling <code class="highlighter-rouge">setRemoteDescription</code> with the message payload.</p>

<p>Now that the client and server have exchanged their media 
capabilities as mandated by WebRTC, all that’s left is to exchange their
 publicly accessible addresses in the form of ICE candidates. On the 
client’s side, <code class="highlighter-rouge">RTCPeerConnection</code> 
manages most of this for us; it performs the ICE protocol using the 
provided STUN server and passes all found ICE candidates to the <code class="highlighter-rouge">rtcPeerConnection.onicecandidate</code> callback. All we have to do then is send the ICE candidates to the server in the function we earlier assigned to <code class="highlighter-rouge">onicecandidate</code>.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onIceCandidate</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span> <span class="o">&amp;&amp;</span> <span class="nx">event</span><span class="p">.</span><span class="nx">candidate</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">webSocketConnection</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'candidate'</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">candidate</span><span class="p">}));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We can handle this message on the server in <code class="highlighter-rouge">OnWebSocketMessage</code>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">OnWebSocketMessage</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="c1">// ... Parse JSON and handle an offer message.
</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="s">"candidate"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"payload"</span><span class="p">][</span><span class="s">"candidate"</span><span class="p">].</span><span class="n">GetString</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">sdp_mline_index</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"payload"</span><span class="p">][</span><span class="s">"sdpMLineIndex"</span><span class="p">].</span><span class="n">GetInt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">sdp_mid</span> <span class="o">=</span> <span class="n">message_object</span><span class="p">[</span><span class="s">"payload"</span><span class="p">][</span><span class="s">"sdpMid"</span><span class="p">].</span><span class="n">GetString</span><span class="p">();</span>
    <span class="n">webrtc</span><span class="o">::</span><span class="n">SdpParseError</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">candidate_object</span> <span class="o">=</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CreateIceCandidate</span><span class="p">(</span><span class="n">sdp_mid</span><span class="p">,</span> <span class="n">sdp_mline_index</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
    <span class="n">peer_connection</span><span class="o">-&gt;</span><span class="n">AddIceCandidate</span><span class="p">(</span><span class="n">candidate_object</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// ... Handle unrecognized type.
</span><span class="p">}</span>
</code></pre>
</div>

<p>The server parses the fields of the JSON blob into a proper WebRTC ICE candidate object which is then saved via <code class="highlighter-rouge">AddIceCandidate</code>.</p>

<p>The server’s own ICE candidates are similarly generated by the peer connection, but this time they are passed to <code class="highlighter-rouge">OnIceCandidate</code> through the <code class="highlighter-rouge">PeerConnectionObserver</code>. We provided our own callback for this function where we can forward the candidates to the client.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">OnIceCandidate</span><span class="p">(</span><span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">IceCandidateInterface</span><span class="o">*</span> <span class="n">candidate</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">candidate_str</span><span class="p">;</span>
  <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">candidate_str</span><span class="p">);</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Document</span> <span class="n">message_object</span><span class="p">;</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">SetObject</span><span class="p">();</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"type"</span><span class="p">,</span> <span class="s">"candidate"</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Value</span> <span class="n">candidate_value</span><span class="p">;</span>
  <span class="n">candidate_value</span><span class="p">.</span><span class="n">SetString</span><span class="p">(</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">StringRef</span><span class="p">(</span><span class="n">candidate_str</span><span class="p">.</span><span class="n">c_str</span><span class="p">()));</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Value</span> <span class="n">sdp_mid_value</span><span class="p">;</span>
  <span class="n">sdp_mid_value</span><span class="p">.</span><span class="n">SetString</span><span class="p">(</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">StringRef</span><span class="p">(</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">sdp_mid</span><span class="p">().</span><span class="n">c_str</span><span class="p">()));</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Value</span> <span class="n">message_payload</span><span class="p">;</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">SetObject</span><span class="p">();</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"candidate"</span><span class="p">,</span> <span class="n">candidate_value</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"sdpMid"</span><span class="p">,</span> <span class="n">sdp_mid_value</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">message_payload</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"sdpMLineIndex"</span><span class="p">,</span> <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">sdp_mline_index</span><span class="p">(),</span>
      <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">AddMember</span><span class="p">(</span><span class="s">"payload"</span><span class="p">,</span> <span class="n">message_payload</span><span class="p">,</span> <span class="n">message_object</span><span class="p">.</span><span class="n">GetAllocator</span><span class="p">());</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">StringBuffer</span> <span class="n">strbuf</span><span class="p">;</span>
  <span class="n">rapidjson</span><span class="o">::</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">StringBuffer</span><span class="o">&gt;</span> <span class="n">writer</span><span class="p">(</span><span class="n">strbuf</span><span class="p">);</span>
  <span class="n">message_object</span><span class="p">.</span><span class="n">Accept</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">strbuf</span><span class="p">.</span><span class="n">GetString</span><span class="p">();</span>
  <span class="n">ws_server</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">websocket_connection_handler</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">websocketpp</span><span class="o">::</span><span class="n">frame</span><span class="o">::</span><span class="n">opcode</span><span class="o">::</span><span class="n">value</span><span class="o">::</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Again, the code is overly verbose because of <code class="highlighter-rouge">rapidjson</code>, but it’s straightforward and analagous to the client’s own <code class="highlighter-rouge">onIceCandidate</code> callback. The server takes the provided ICE candidate, parses its fields into a JSON object, and sends it via the WebSocket.</p>

<p>The client receives the ICE candidate from the server in <code class="highlighter-rouge">onWebSocketMessage</code> where it also makes a call to <code class="highlighter-rouge">addIceCandidate</code>.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onWebSocketMessage</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... Parse string and handle answer.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">messageObject</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'candidate'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addIceCandidate</span><span class="p">(</span><span class="k">new</span> <span class="nx">RTCIceCandidate</span><span class="p">(</span><span class="nx">messageObject</span><span class="p">.</span><span class="nx">payload</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// ... Handle unrecognized type.</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If you did everything correctly, calling <code class="highlighter-rouge">connect</code> on the client should now initiate and (hopefully) complete the handshake with the server. We can verify by using the <code class="highlighter-rouge">onDataChannelOpen</code> callback we assigned earlier to <code class="highlighter-rouge">dataChannel.onopen</code>.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onDataChannelOpen</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Data channel opened!'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If the handshake was successful, <code class="highlighter-rouge">onDataChennelOpen</code>
 should get fired, and a congratulatory message will be output to the 
console! We can then use this newly opened data channel to ping the 
server.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">ping</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dataChannel</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'ping'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The server similarly receives an event when the data channel was successfully opened. This is triggered through the <code class="highlighter-rouge">OnDataChannelCreated</code> callback via the <code class="highlighter-rouge">PeerConnectionObserver</code>.
 Unlike the client, however, the server has one extra step to do. On 
opening the original data channel, the WebRTC library creates a new data
 channel with updated fields which is passed as an argument to the <code class="highlighter-rouge">OnDataChannelCreated</code>
 callback. This step is abstracted away in the client code, but it’s not
 terribly difficult to reassign the new data channel and rebind the <code class="highlighter-rouge">DataChannelObserver</code> on the server.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">OnDataChannelCreated</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">DataChannelInterface</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">data_channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
  <span class="n">data_channel</span><span class="o">-&gt;</span><span class="n">RegisterObserver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_channel_observer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Since the <code class="highlighter-rouge">DataChannelObserver</code> is now rebound to the correct data channel, the server can now begin receiving messages via its <code class="highlighter-rouge">OnDataChannelMessage</code> callback.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">OnDataChannelMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">DataBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"pong"</span><span class="p">;</span>
  <span class="n">webrtc</span><span class="o">::</span><span class="n">DataBuffer</span> <span class="n">resp</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()),</span> <span class="nb">false</span> <span class="cm">/* binary array */</span><span class="p">);</span>
  <span class="n">data_channel</span><span class="o">-&gt;</span><span class="n">Send</span><span class="p">(</span><span class="n">resp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This prints the received ping (managed by a WebRTC <code class="highlighter-rouge">DataBuffer</code>) to standard output and responds with a pong. The client can handle the pong via the <code class="highlighter-rouge">onDataChannelMessage</code> which we assigned to <code class="highlighter-rouge">dataChannel.onmessage</code>.</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nx">example</span><span class="o">-</span><span class="nx">client</span><span class="p">.</span><span class="nx">js</span><span class="p">]</span>
<span class="kd">function</span> <span class="nx">onDataChannelMessage</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>And finally, we’re done! If implemented correctly, we reap the fruits of our labor by calling <code class="highlighter-rouge">ping</code>
 which will send a “ping” message to the server. The server handles the 
client’s message, printing “ping” to standard output and sends back a 
“pong” message. Upon reception of the server’s message, the client 
outputs “pong” to the browser console.</p>

<h2 id="benchmarks">Benchmarks</h2>
<p>Whew, that was a lot of concepts and code just to establish a simple 
connection. Initializing a similar connection with WebSockets only takes
 around 10 lines of client code and 20 lines of server code. Given this 
disparity in upfront costs, is WebRTC with its associated boilerplate 
even worth it? I ran some benchmarks to find out.</p>

<p>In the first test, I sent 20 pings a second from the client to the 
server for 20 seconds and measured the round trip time. I did this on a 
“perfect connection” with no packet loss for both WebRTC data channels 
(SCTP) and a simple WebSockets connection (TCP).</p>

<p><img src="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/no-packet-loss.png"></p>

<p>As expected, in the absence of packet loss, both WebRTC and 
WebSockets perform acceptably with WebRTC RTT clustered around 40-50ms 
and WebSockets averaging around 80-90ms. There is definitely some amount
 of overhead in the TCP protocol, but for most games, an extra 50ms or 
so won’t make or break the player experience.</p>

<p>In the second test, I sent pings at the same rate for the same 
duration, but I also used a traffic shaper to drop 5% of outgoing 
packets and 5% of incoming packets. Again, I tested on both WebRTC and 
WebSockets.</p>

<p><img src="A_comprehensive_dive_into_WebRTC_for_client-server_web_games_%C2%B7_beep_boop_files/packet-loss.png" alt="Packet loss"></p>

<p>Admittedly, a 5% drop rate is a bit exaggerated, but the results are 
striking regardless. Since we are transmitting in unreliable SCTP for 
WebRTC, the distribution of RTT is completely unaffected. We dropped 
around 40 packets, but in the context of a game where the server sends 
state 20 times a second, this is a non-issue. The WebSocket 
implementation, on the other hand, has a long tail with some packets not
 arriving for over 900ms. Even worse, a very large percentage of packets
 had a RTT of over 250ms which would result in an extremely annoying 
experience that any gamer can attest to.</p>

<h2 id="conclusion">Conclusion</h2>
<p>Though it took a lot of persistence, we were eventually able to 
shoehorn WebRTC into a client-server architecture. We implemented an 
example of a data channel connection that performs vastly better than 
WebSockets for both perfect connections and networks with packet loss. 
The example code, however, is largely illustrative and contains a whole 
host of suboptimal patterns. In addition to the global variables 
littered throughout the code, the server also contains a glaring 
inefficiency in its immediate handling of data channel messages in the <code class="highlighter-rouge">OnDataChannelMessage</code>
 callback. The cost of doing so in our example is negligible, but in an 
actual game server, the message handler will be a more costly function 
that must interact with state. The message handling function will then 
block the signaling thread from processing any other messages on the 
wire during its execution. To avoid this, I recommend pushing all 
messages onto a thread-safe message queue, and during the next game 
tick, the main game loop running in a different thread can process the 
network messages in batch. I use <a href="https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h">Facebook’s lock-free queue</a> in my own game server for this. For ideas on how to better organize your game around WebRTC, feel free to take a look at my <a href="https://github.com/brkho/archipelago-server">server code</a> and <a href="https://github.com/brkho/archipelago-client">client code</a>.</p>

<p>There are also a couple caveats worth mentioning about WebRTC. First, WebRTC is not even supported yet in every major browser<sup>11</sup>.
 While both Firefox and Chrome have been on the list of supporting 
browsers for a long time, Safari and Edge are notably absent. I’m 
comfortable only supporting modern Firefox and Chrome in my own game, 
but depending your target audience, it might make more sense to just 
distribute a native client.</p>

<p>In addition, I mentioned earlier that corporate networks behind 
symmetric NAT devices cannot use STUN. This is because symmetric NAT 
offers additional security by not only associating a local IP with a 
port, but also with a destination. The NAT device will then only accept 
connections on the associated port <em>from</em> the original 
destination server. This means that while the STUN server can still 
discover the client’s NAT IP, that address is useless to other peers 
because only the STUN server can respond along it.</p>

<p>To solve this, we can use a different protocol called TURN which 
simply acts as a relay server that forwards packets in between the two 
peers. This approach, however, is suboptimal because it inflates round 
trip time between the peers as a result of the indirection. An 
interesting approach that I don’t think has been explored yet is to 
combine the TURN server with your game server, but run a custom TURN 
implementation that directly pushes the received packets to your game 
loop’s message queue. This solves the symmetric NAT problem and is even 
more efficient than the approach described in this blog post. I’m most 
likely going to experiment with this after I flesh out my game a bit 
more. Stay tuned!</p>

<p>Despite these setbacks, the WebRTC data channel is still a powerful 
tool which can be leveraged to improve the responsiveness of many web 
games. I’m excited about the future of WebRTC adoption and hopeful that 
it will usher in the next generation of massively multiplayer browser 
experiences.</p>

<p>Thanks for reading, and if you have any questions, please feel free to <a href="http://blog.brkho.com/about/">contact me</a> or leave a comment below!</p>

<h2 id="references">References</h2>
<ol>
  <li>https://www.superdataresearch.com/us-digital-games-market/</li>
  <li>http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/</li>
  <li>http://gamedev.stackexchange.com/questions/431/is-the-tcp-protocol-good-enough-for-real-time-multiplayer-games</li>
  <li>http://gafferongames.com/networking-for-game-programmers/</li>
  <li>http://new.gafferongames.com/post/why_cant_i_send_udp_packets_from_a_browser/</li>
  <li>https://www.html5rocks.com/en/tutorials/webrtc/basics/</li>
  <li>https://news.ycombinator.com/item?id=13741155</li>
  <li>https://news.ycombinator.com/item?id=13264952</li>
  <li>http://gamedev.stackexchange.com/questions/67738/limitations-of-p2p-multiplayer-games-vs-client-server</li>
  <li>https://github.com/js-platform/node-webrtc/issues/257</li>
  <li>http://caniuse.com/#feat=rtcpeerconnection</li>
</ol>

</div>

<iframe style="background-color: rgb(255, 255, 255) !important; border: 1px solid rgb(236, 147, 41) !important; min-width: 220px !important; min-height: 210px !important; max-height: 600px !important; pointer-events: all !important; z-index: 999 !important; width: 1885px !important;" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;html, body {
  color: #303030 !important;
  height: 100% !important;
  overflow: hidden !important;
}
#btn-once-09927113942560609 {
  border: 2px solid #f06a0a !important;
  background-color: #f06a0a !important;
  color: #fefefe !important;
}
#btn-site-0294339493971271 {
  border: 2px solid #333 !important;
  background-color: #fefefe !important;
  color: #333 !important;
}
#btn-once-09927113942560609:hover {
  background-color: #fefefe !important;
  color: #333 !important;
}
#btn-site-0294339493971271:hover {
  background-color: #fefefe !important;
  border: 2px solid #f06a0a !important;
}
#ico-help-03375845383050625, #ico-close-05063474375033772 {
  position: absolute;
  right: 4px;
  top: 4px;
  line-height: 12px;
  text-align: center;
  text-decoration: none;
}
#ico-close-05063474375033772 {
  left: 4px;
  width: 20px;
}
#ico-help-03375845383050625:before, #ico-close-05063474375033772:before {
  border: 2px solid;
  border-radius: 50%;
  display: inline-block;
  color: #555;
  content: '?';
  font-size: 12px;
  font-weight: bold;
  padding: 1px;
  height: 1em;
  width: 1em;
}
#ico-close-05063474375033772:before {
  border: 0;
  content: '✕';
  padding: 4px;
}
#ico-help-03375845383050625:hover:before, #ico-close-05063474375033772:hover:before {
  color: #ec9329;
}
a {
  text-decoration: underline;
  color: black;
}
a:hover {
  color: #ec9329;
}
@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
  }
  body {
    background-color: #333 !important;
    color: #ddd !important;
  }
  a, a:visited {
    color: #ddd !important;
  }
  a:hover {
    color: #f06a0a !important;
  }
  #ico-help-03375845383050625:before, #ico-close-05063474375033772:before {
    color: #aaa;
  }
  #btn-site-0294339493971271 {
    background-color: #333 !important;
    border: solid 2px #ddd !important;
    color: #ddd !important;
  }
  #btn-once-09927113942560609:hover, #btn-site-0294339493971271:hover {
    background-color: #333 !important;
    color: #ddd !important;
  }
}&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;margin:0&quot;&gt;&lt;div style=&quot;display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: center !important; width: 100% !important; height: 100% !important;&quot;&gt;&lt;div style=&quot;font-family: helvetica, arial, sans-serif !important; font-size: 16px !important; display: flex !important; flex-wrap: wrap !important; justify-content: center !important; text-align: center !important; margin: 10px !important;&quot;&gt;Privacy Badger has replaced this Disqus widget&lt;a id=&quot;ico-close-05063474375033772&quot; href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;&lt;a id=&quot;ico-help-03375845383050625&quot; href=&quot;https://privacybadger.org/#How-does-Privacy-Badger-handle-social-media-widgets&quot; rel=&quot;noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;font-family: helvetica, arial, sans-serif !important; font-size: 16px !important; display: flex !important; flex-wrap: wrap !important; justify-content: center !important; text-align: center !important; margin: 10px !important; width: 100% !important;&quot;&gt;&lt;button id=&quot;btn-once-09927113942560609&quot; style=&quot;transition: background-color 0.25s ease-out 0s, border-color 0.25s ease-out 0s, color 0.25s ease-out 0s !important; border-radius: 3px !important; cursor: pointer !important; font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif !important; font-size: 14px !important; font-weight: bold !important; line-height: 16px !important; padding: 10px !important; margin: 4px !important; width: 70% !important; max-width: 280px !important;&quot;&gt;Allow once&lt;/button&gt;&lt;button id=&quot;btn-site-0294339493971271&quot; style=&quot;transition: background-color 0.25s ease-out 0s, border-color 0.25s ease-out 0s, color 0.25s ease-out 0s !important; border-radius: 3px !important; cursor: pointer !important; font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, Ubuntu, roboto, noto, segoe ui, arial, sans-serif !important; font-size: 14px !important; font-weight: bold !important; line-height: 16px !important; padding: 10px !important; margin: 4px !important; width: 70% !important; max-width: 280px !important;&quot;&gt;Always allow on this site&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"></iframe>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://brkho.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<br>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  

</body></html>